/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\nvar _TransferElements_instances, assembleBreakpoints_fn, getChildElementsOfTargetElement_fn, getBreakpointTrigger_fn, getScrollbarWidth_fn, getObjectType_fn, isTargetElementDescendantOfSourceElement_fn, isTagOfTargetElementSelfClosing_fn, sortBreakpointObjects_fn, removeSourceElements_fn, insertSourceElements_fn, throwExceptionIfMaximumTargetPositionIsExceeded_fn, generateBreakpointObject_fn;\nclass TransferElements {\n  constructor(...objectsWithParameters) {\n    __privateAdd(this, _TransferElements_instances);\n    if (objectsWithParameters.length === 0) {\n      throw TypeError(\"at least one object with parameters must be specified for the constructor\");\n    }\n    const sourceElements = [];\n    const validatedObjectsWithParameters = objectsWithParameters.map((objectWithParameters) => {\n      if (__privateMethod(this, _TransferElements_instances, getObjectType_fn).call(this, objectWithParameters) !== \"[object Object]\") {\n        throw TypeError(`the arguments specified for the constructor must be objects of type 'Object'`);\n      }\n      [\"sourceElement\", \"breakpoints\"].forEach((parameterKey) => {\n        if (!Object.hasOwn(objectWithParameters, parameterKey)) {\n          throw TypeError(`the '${parameterKey}' parameter is not specified for the main object`);\n        }\n      });\n      const { sourceElement, breakpoints } = objectWithParameters;\n      if (!(sourceElement instanceof Element)) {\n        throw TypeError(`the value specified for the 'sourceElement' parameter must be an object of type 'Element'`);\n      }\n      if (sourceElements.includes(sourceElement)) {\n        throw TypeError(\n          `there can only be one object in the constructor with such a 'sourceElement': '${sourceElement.cloneNode().outerHTML}'`\n        );\n      }\n      sourceElements.push(sourceElement);\n      objectWithParameters.breakpoints = __privateMethod(this, _TransferElements_instances, assembleBreakpoints_fn).call(this, breakpoints, sourceElement);\n      return objectWithParameters;\n    });\n    const sortedBreakpointTriggers = [\n      ...validatedObjectsWithParameters.reduce(\n        (collection, { breakpoints }) => {\n          Object.keys(breakpoints).forEach((breakpointTrigger) => {\n            if (Number(breakpointTrigger)) {\n              collection.add(breakpointTrigger);\n            }\n          });\n          return collection;\n        },\n        /* @__PURE__ */ new Set()\n      ).add(\"default\")\n    ].sort((a, b) => a - b);\n    const storageOfBreakpoints = sortedBreakpointTriggers.reduce(\n      (storage, breakpointTrigger) => {\n        storage.set(breakpointTrigger, []);\n        return storage;\n      },\n      /* @__PURE__ */ new Map()\n    );\n    validatedObjectsWithParameters.forEach(({ sourceElement, breakpoints }) => {\n      Object.entries(breakpoints).forEach(([breakpointTrigger, { targetElement, targetPosition }]) => {\n        storageOfBreakpoints.get(breakpointTrigger).push({\n          sourceElement,\n          targetElement,\n          targetPosition\n        });\n      });\n    });\n    storageOfBreakpoints.forEach((breakpointObjects) => {\n      __privateMethod(this, _TransferElements_instances, sortBreakpointObjects_fn).call(this, breakpointObjects);\n      __privateMethod(this, _TransferElements_instances, removeSourceElements_fn).call(this, breakpointObjects);\n      __privateMethod(this, _TransferElements_instances, insertSourceElements_fn).call(this, breakpointObjects, true);\n      breakpointObjects.length = 0;\n      sourceElements.forEach((sourceElement) => {\n        breakpointObjects.push(__privateMethod(this, _TransferElements_instances, generateBreakpointObject_fn).call(this, sourceElement, true));\n      });\n      __privateMethod(this, _TransferElements_instances, sortBreakpointObjects_fn).call(this, breakpointObjects);\n    });\n    let previousBreakpointTrigger = \"default\";\n    const resizeObserver = new ResizeObserver(\n      ([\n        {\n          borderBoxSize: [{ inlineSize }],\n          target\n        }\n      ]) => {\n        const currentWidth = inlineSize + __privateMethod(this, _TransferElements_instances, getScrollbarWidth_fn).call(this, target);\n        const currentBreakpointTrigger = __privateMethod(this, _TransferElements_instances, getBreakpointTrigger_fn).call(this, sortedBreakpointTriggers, currentWidth);\n        if (previousBreakpointTrigger !== currentBreakpointTrigger) {\n          const breakpointObjects = storageOfBreakpoints.get(currentBreakpointTrigger);\n          __privateMethod(this, _TransferElements_instances, removeSourceElements_fn).call(this, breakpointObjects);\n          __privateMethod(this, _TransferElements_instances, insertSourceElements_fn).call(this, breakpointObjects, false);\n          previousBreakpointTrigger = currentBreakpointTrigger;\n        }\n      }\n    );\n    resizeObserver.observe(document.documentElement);\n  }\n}\n_TransferElements_instances = new WeakSet();\nassembleBreakpoints_fn = function(breakpoints, sourceElement) {\n  if (__privateMethod(this, _TransferElements_instances, getObjectType_fn).call(this, breakpoints) !== \"[object Object]\") {\n    throw TypeError(`the value specified for the 'breakpoints' parameter must be an object of type 'Object'`);\n  }\n  const breakpointEntries = Object.entries(breakpoints);\n  if (breakpointEntries.length === 0) {\n    throw TypeError(`at least one breakpoint must be specified for the 'breakpoints' object`);\n  }\n  const validatedBreakpoints = Object.fromEntries(\n    breakpointEntries.map(([breakpointTrigger, breakpointObject]) => {\n      const breakpointTriggerAsNumber = Number(breakpointTrigger);\n      if (!breakpointTriggerAsNumber || breakpointTriggerAsNumber <= 0 || breakpointTriggerAsNumber > Number.MAX_SAFE_INTEGER) {\n        throw RangeError(`the breakpoint trigger must be a safe (integer or fractional) number greater than zero`);\n      }\n      if (__privateMethod(this, _TransferElements_instances, getObjectType_fn).call(this, breakpointObject) !== \"[object Object]\") {\n        throw TypeError(`the breakpoint object must be of type 'Object'`);\n      }\n      if (!Object.hasOwn(breakpointObject, \"targetElement\")) {\n        throw TypeError(`the 'targetElement' parameter is not specified for the breakpoint object`);\n      }\n      const { targetElement, targetPosition } = breakpointObject;\n      if (!(targetElement instanceof Element)) {\n        throw TypeError(`the value specified for the 'targetElement' parameter must be an object of type 'Element'`);\n      }\n      if (sourceElement === targetElement) {\n        throw TypeError(\n          `the value specified for the 'targetElement' parameter must be different from the value specified for the 'sourceElement' parameter`\n        );\n      }\n      if (__privateMethod(this, _TransferElements_instances, isTargetElementDescendantOfSourceElement_fn).call(this, targetElement, sourceElement)) {\n        throw TypeError(\n          `the element that is specified as the value for the 'targetElement' parameter must not be a descendant of the element specified as the value for the 'sourceElement' parameter`\n        );\n      }\n      if (__privateMethod(this, _TransferElements_instances, isTagOfTargetElementSelfClosing_fn).call(this, targetElement)) {\n        throw TypeError(`the element specified as the value for the 'targetElement' parameter must be a paired tag`);\n      }\n      if (Object.hasOwn(breakpointObject, \"targetPosition\")) {\n        if (typeof targetPosition !== \"number\") {\n          throw TypeError(`the value specified for the 'targetPosition' parameter must be of type 'number'`);\n        }\n        if (targetPosition < 0 || !Number.isSafeInteger(targetPosition)) {\n          throw RangeError(\n            `the number specified as the value for the 'targetPosition' parameter must be a non-negative safe integer`\n          );\n        }\n      }\n      return [\n        breakpointTriggerAsNumber,\n        __spreadValues({\n          targetPosition: targetPosition != null ? targetPosition : 0\n        }, breakpointObject)\n      ];\n    })\n  );\n  validatedBreakpoints.default = __privateMethod(this, _TransferElements_instances, generateBreakpointObject_fn).call(this, sourceElement, false);\n  return validatedBreakpoints;\n};\ngetChildElementsOfTargetElement_fn = function(targetElement) {\n  return targetElement.children;\n};\ngetBreakpointTrigger_fn = function(breakpointTriggers, currentWidth) {\n  let startIndex = 0;\n  let endIndex = breakpointTriggers.length - 2;\n  let savedBreakpointTrigger;\n  while (startIndex <= endIndex) {\n    const middleIndex = Math.floor((startIndex + endIndex) / 2);\n    const guessedBreakpointTrigger = breakpointTriggers[middleIndex];\n    if (guessedBreakpointTrigger == currentWidth) {\n      return guessedBreakpointTrigger;\n    } else if (guessedBreakpointTrigger > currentWidth) {\n      endIndex = middleIndex - 1;\n    } else {\n      startIndex = middleIndex + 1;\n    }\n    if (guessedBreakpointTrigger - currentWidth > 0) {\n      savedBreakpointTrigger = guessedBreakpointTrigger;\n    }\n  }\n  return savedBreakpointTrigger != null ? savedBreakpointTrigger : \"default\";\n};\ngetScrollbarWidth_fn = function(observableElement) {\n  const viewportWidth = window.innerWidth;\n  const widthOfObservableElement = Math.min(observableElement.clientWidth, observableElement.offsetWidth);\n  let scrollbarWidth = 0;\n  if (widthOfObservableElement !== viewportWidth) {\n    scrollbarWidth += viewportWidth - widthOfObservableElement;\n  }\n  return scrollbarWidth;\n};\ngetObjectType_fn = function(object) {\n  return Object.prototype.toString.call(object);\n};\nisTargetElementDescendantOfSourceElement_fn = function(targetElement, sourceElement) {\n  while (targetElement = targetElement.parentElement) {\n    if (targetElement === sourceElement) {\n      return true;\n    }\n  }\n  return false;\n};\nisTagOfTargetElementSelfClosing_fn = function(targetElement) {\n  return !new RegExp(/<\\/[a-zA-Z]+>$/).test(targetElement.outerHTML);\n};\nsortBreakpointObjects_fn = function(breakpointObjects) {\n  if (breakpointObjects.length > 1) {\n    breakpointObjects.sort((a, b) => a.targetPosition - b.targetPosition);\n  }\n};\nremoveSourceElements_fn = function(breakpointObjects) {\n  breakpointObjects.forEach(({ sourceElement }) => {\n    sourceElement.remove();\n  });\n};\ninsertSourceElements_fn = function(breakpointObjects, hasCheckOfMaximumTargetPosition) {\n  breakpointObjects.forEach(({ sourceElement, targetElement, targetPosition }) => {\n    const childElementsOfTargetElement = __privateMethod(this, _TransferElements_instances, getChildElementsOfTargetElement_fn).call(this, targetElement);\n    if (hasCheckOfMaximumTargetPosition) {\n      __privateMethod(this, _TransferElements_instances, throwExceptionIfMaximumTargetPositionIsExceeded_fn).call(this, childElementsOfTargetElement, targetPosition);\n    }\n    const childElementOfTargetElement = childElementsOfTargetElement[targetPosition];\n    if (childElementOfTargetElement) {\n      childElementOfTargetElement.before(sourceElement);\n    } else {\n      targetElement.append(sourceElement);\n    }\n  });\n};\nthrowExceptionIfMaximumTargetPositionIsExceeded_fn = function(childElementsOfTargetElement, targetPosition) {\n  const maximumTargetPosition = childElementsOfTargetElement.length;\n  if (targetPosition > maximumTargetPosition) {\n    throw RangeError(\n      `the number specified as the value for the 'targetPosition' parameter exceeds the maximum allowed value of '${maximumTargetPosition}'`\n    );\n  }\n};\ngenerateBreakpointObject_fn = function(sourceElement, isComplete) {\n  const parentElementOfSourceElement = sourceElement.parentElement;\n  const breakpointObject = {\n    targetElement: parentElementOfSourceElement,\n    targetPosition: [...parentElementOfSourceElement.children].findIndex(\n      (childElementOfSourceElement) => childElementOfSourceElement === sourceElement\n    )\n  };\n  if (isComplete) {\n    breakpointObject.sourceElement = sourceElement;\n  }\n  return breakpointObject;\n};\nconst _BaseHelpers = class _BaseHelpers {\n  static addTouchClass() {\n    if (MobileChecker.isAny) {\n      _BaseHelpers.html.classList.add(\"touch\");\n    }\n  }\n  static addLoadedClass() {\n    window.addEventListener(\"load\", () => {\n      setTimeout(() => {\n        _BaseHelpers.html.classList.add(\"loaded\");\n      }, 0);\n    });\n  }\n  static get getHash() {\n    var _a;\n    return (_a = location.hash) == null ? void 0 : _a.replace(\"#\", \"\");\n  }\n  static calcScrollbarWidth() {\n    const scrollbarWidth = (window.innerWidth - document.body.clientWidth) / 16 + \"rem\";\n    _BaseHelpers.html.style.setProperty(\"--bh-scrollbar-width\", scrollbarWidth);\n  }\n};\n__publicField(_BaseHelpers, \"html\", document.documentElement);\nlet BaseHelpers = _BaseHelpers;\nconst _MobileChecker = class _MobileChecker {\n  static get isAndroid() {\n    return Boolean(_MobileChecker.userAgent.match(/Android/i));\n  }\n  static get isBlackBerry() {\n    return Boolean(_MobileChecker.userAgent.match(/BlackBerry/i));\n  }\n  static get isAppleOS() {\n    return Boolean(_MobileChecker.userAgent.match(/iPhone|iPad|iPod/i));\n  }\n  static get isOpera() {\n    return Boolean(_MobileChecker.userAgent.match(/Opera Mini/i));\n  }\n  static get isWindows() {\n    return Boolean(_MobileChecker.userAgent.match(/IEMobile/i));\n  }\n  static get isAny() {\n    return _MobileChecker.isAndroid || _MobileChecker.isBlackBerry || _MobileChecker.isAppleOS || _MobileChecker.isOpera || _MobileChecker.isWindows;\n  }\n};\n__publicField(_MobileChecker, \"userAgent\", navigator.userAgent);\nlet MobileChecker = _MobileChecker;\nclass Accordion {\n  constructor(opts = {}) {\n    const defaultConfig = {\n      accordion: \".accordion\",\n      button: \".accordion-btn\",\n      panel: \".accordion-panel\",\n      activeClass: \"active\"\n    };\n    this.options = Object.assign(defaultConfig, opts);\n    this.accordions = document.querySelectorAll(this.options.accordion);\n    this.setState();\n  }\n  listener() {\n    this.accordions.forEach((ac) => {\n      const btn = ac.querySelector(this.options.button);\n      const panel = ac.querySelector(this.options.panel);\n      btn.addEventListener(\"click\", (e) => this.slidepanel(e, ac, btn, panel));\n    });\n  }\n  slidepanel(e, ac, btn, panel) {\n    panel.classList.toggle(this.options.activeClass);\n    if (panel.classList.contains(this.options.activeClass)) {\n      panel.style.maxHeight = panel.scrollHeight + \"px\";\n    } else {\n      panel.style.maxHeight = \"0px\";\n      ac.classList.remove(this.options.activeClass);\n    }\n    btn.classList.toggle(this.options.activeClass);\n    e.preventDefault();\n  }\n  setState() {\n    this.accordions.forEach((ac) => {\n      const btn = ac.querySelector(this.options.button);\n      const panel = ac.querySelector(this.options.panel);\n      const acActive = ac.classList.contains(this.options.activeClass);\n      const btnActive = btn.classList.contains(this.options.activeClass);\n      if (btnActive || acActive) {\n        btn.classList.add(this.options.activeClass);\n        panel.classList.add(this.options.activeClass);\n        panel.style.maxHeight = panel.scrollHeight + \"px\";\n      } else {\n        btn.classList.remove(this.options.activeClass);\n        panel.classList.remove(this.options.activeClass);\n        panel.style.maxHeight = \"0px\";\n      }\n    });\n  }\n}\nBaseHelpers.addLoadedClass();\nBaseHelpers.calcScrollbarWidth();\nBaseHelpers.addTouchClass();\nconst isEven = (num) => num % 2 === 0;\nwindow.addEventListener(\"DOMContentLoaded\", function() {\n  const burgerBtn = document.querySelector(\"#mobile-burger\");\n  const mobileNav = document.querySelector(\"#mobile-nav\");\n  const body = document.querySelector(\"body\");\n  if (burgerBtn && mobileNav) {\n    burgerBtn.addEventListener(\"click\", () => {\n      const mobileTile = mobileNav.querySelector(\".mobile-tile\");\n      mobileTile.scrollTo({ top: mobileTile.scrollHeight });\n      setTimeout(function() {\n        mobileTile.scrollTo({\n          top: 0,\n          behavior: \"smooth\"\n        });\n      }, 1e3);\n      mobileNav.classList.toggle(\"show\");\n    });\n    mobileNav.addEventListener(\"click\", () => {\n      const mobileTile = mobileNav.querySelector(\".mobile-tile\");\n      mobileTile.scrollTo({\n        top: mobileTile.scrollHeight,\n        behavior: \"smooth\"\n      });\n      mobileNav.classList.remove(\"show\");\n    });\n  } else {\n    console.log(\"Mobile navigation HTML in DOM is broken !\");\n  }\n  new Accordion({\n    accordion: \".accordion\",\n    button: \".accordion-btn\",\n    panel: \".accordion-panel\",\n    activeClass: \"active\"\n  }).listener();\n  const transferContainer = document.getElementById(\"main-transfer-cont\");\n  const transferDescription = document.getElementById(\"main-transfer-desc\");\n  if (transferContainer && transferDescription) {\n    new TransferElements({\n      sourceElement: transferDescription,\n      breakpoints: {\n        768: {\n          targetElement: transferContainer,\n          targetPosition: 0\n        }\n      }\n    });\n  }\n  const shopProducts = document.querySelector(\".products\");\n  if (shopProducts) {\n    let remove2 = function() {\n      if (mediaSM.matches) {\n        if (!isEven(allProducts.length)) {\n          allProducts[allProducts.length - 1].style.display = \"none\";\n        }\n      } else {\n        allProducts[allProducts.length - 1].style.display = \"block\";\n      }\n    };\n    var remove = remove2;\n    const allProducts = shopProducts.querySelectorAll(\".product-card\");\n    const mediaSM = window.matchMedia(\"(max-width: 765px)\");\n    remove2();\n    window.addEventListener(\"resize\", remove2);\n  }\n  const expireDate = document.getElementById(\"expiry-date\");\n  function updatePlaceholder() {\n    if (window.innerWidth < 768) {\n      expireDate.placeholder = \"MM/YY\";\n    } else {\n      expireDate.placeholder = \"\";\n    }\n  }\n  if (expireDate) {\n    window.onload = updatePlaceholder;\n    window.onresize = updatePlaceholder;\n  }\n  const mainGalleryGrid = document.querySelector(\"#main-gallery-grid\");\n  const galleryBox = document.querySelector(\"#main-gallery-box\");\n  function updateGridHeight() {\n    if (window.innerWidth < 768) {\n      const item1height = getSumOfChildrenHeight(mainGalleryGrid.querySelector(\".item-1\"));\n      const item2height = getSumOfChildrenHeight(mainGalleryGrid.querySelector(\".item-2\"));\n      const item3height = getSumOfChildrenHeight(mainGalleryGrid.querySelector(\".item-3\"));\n      const item4height = getSumOfChildrenHeight(mainGalleryGrid.querySelector(\".item-4\"));\n      const finishHeight = max(item2height, item4height) + max(item1height, item3height) + 21;\n      if (item4height <= item2height) {\n        galleryBox.style.minHeight = item2height + \"px\";\n      } else {\n        galleryBox.style.minHeight = item4height + \"px\";\n      }\n      mainGalleryGrid.style.maxHeight = finishHeight + \"px\";\n    } else {\n      mainGalleryGrid.style.removeProperty(\"max-height\");\n      galleryBox.style.removeProperty(\"min-height\");\n    }\n  }\n  if (mainGalleryGrid) {\n    window.onload = updateGridHeight;\n    window.onresize = updateGridHeight;\n  }\n  function getSumOfChildrenHeight(parentElement) {\n    let sum = 0;\n    for (const child of parentElement.children) {\n      sum += child.offsetHeight;\n    }\n    return sum;\n  }\n  function max(a, b) {\n    if (a > b) {\n      return a;\n    } else {\n      return b;\n    }\n  }\n  const galleryPage = document.querySelector(\"#gallery-page\");\n  if (galleryPage) {\n    const firstGalleryArticle = galleryPage.querySelector(\".gallery-article\");\n    const firstGalleryArticleDate = firstGalleryArticle.querySelector(\".gallery-article_date\");\n    const firstGalleryArticleTitle = firstGalleryArticle.querySelector(\".gallery-article_title\");\n    if (firstGalleryArticle && firstGalleryArticleDate && firstGalleryArticleTitle) {\n      firstGalleryArticleDate.classList.add(\"first-gallery_date\");\n      firstGalleryArticleTitle.classList.add(\"first-gallery_title\");\n    }\n  }\n  const mainAnounce = document.querySelector(\".main-anounce\");\n  const header = document.querySelector(\".header\");\n  if (mainAnounce) {\n    header.classList.add(\"header-black\");\n  }\n});\nconst cookieWindow = document.getElementById(\"cookies-window\");\nconst cookieCloseButton = document.getElementById(\"cookies-close\");\nif (cookieCloseButton) {\n  cookieCloseButton.addEventListener(\"click\", () => {\n    cookieWindow.classList.remove(\"active\");\n  });\n}\n\n\n//# sourceURL=webpack:///./main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./main.js"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;